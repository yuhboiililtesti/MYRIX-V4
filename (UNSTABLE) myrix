#!/usr/bin/env bash
# MYRIX - My Reliable Infrastructure eXecutor
# Author: yuhboiililtesti
# Repo: https://github.com/yuhboiililtesti/MYRIX-V4

set -euo pipefail
IFS=$'\n\t'

# Global vars
CONFIG_FILE="${HOME}/.myrix_autofill.conf"
LOG_FILE="${HOME}/.myrix.log"
BACKUP_DIR="${HOME}/myrix_backups"
PLEX_SERVICE="plexmediaserver"
MC_SERVICE="minecraft"
DUCKDNS_DIR="${HOME}/duckdns"
DATE=$(date '+%Y-%m-%d_%H-%M-%S')

# Load config autofill or set defaults
declare -A CONFIG
if [[ -f "$CONFIG_FILE" ]]; then
  while IFS='=' read -r key val; do
    key="${key// /}" # remove spaces
    val="${val//\"/}" # remove quotes
    [[ -z "$key" || "$key" =~ ^# ]] && continue
    CONFIG[$key]=$val
  done < "$CONFIG_FILE"
fi

BACKUP_DIR="${CONFIG[backup_dir]:-$BACKUP_DIR}"
PLEX_SERVICE="${CONFIG[plex_service]:-$PLEX_SERVICE}"
MC_SERVICE="${CONFIG[minecraft_service]:-$MC_SERVICE}"
DUCKDNS_DIR="${CONFIG[duckdns_dir]:-$DUCKDNS_DIR}"

# Logging function with timestamp and user
log() {
  local msg="$1"
  echo "$(date '+%F %T') [$(whoami)] $msg" | tee -a "$LOG_FILE"
}

# Utility: Check if a systemd service is active
is_active() {
  systemctl is-active --quiet "$1"
}

# Utility: Start service with idempotency
service_start() {
  local svc="$1"
  if is_active "$svc"; then
    log "$svc already running. Start skipped."
  else
    systemctl start "$svc"
    log "$svc started."
  fi
}

# Utility: Stop service with idempotency
service_stop() {
  local svc="$1"
  if ! is_active "$svc"; then
    log "$svc not running. Stop skipped."
  else
    systemctl stop "$svc"
    log "$svc stopped."
  fi
}

# Plex Commands --------------------------------------------------------------
plex_status() {
  systemctl status "$PLEX_SERVICE"
}

plex_start() {
  service_start "$PLEX_SERVICE"
}

plex_stop() {
  service_stop "$PLEX_SERVICE"
}

plex_restart() {
  systemctl restart "$PLEX_SERVICE"
  log "Plex restarted."
}

plex_reload() {
  systemctl reload "$PLEX_SERVICE"
  log "Plex config reloaded."
}

plex_fix() {
  log "Running Plex auto-fix diagnostics..."
  plex_diagnose_db
  plex_reset_perms
  plex_purge_cache
  plex_restart
  log "Plex auto-fix completed."
}

plex_diagnose_db() {
  local plex_db_path="/var/lib/plexmediaserver/Library/Application Support/Plex Media Server/Plug-in Support/Databases/com.plexapp.plugins.library.db"
  if [[ -f "$plex_db_path" ]]; then
    log "Checking Plex DB integrity..."
    sqlite3 "$plex_db_path" "PRAGMA integrity_check;"
  else
    log "Plex DB not found at $plex_db_path"
  fi
}

plex_purge_cache() {
  local cache_dir="/var/lib/plexmediaserver/Library/Application Support/Plex Media Server/Cache"
  if [[ -d "$cache_dir" ]]; then
    rm -rf "${cache_dir:?}/"*
    log "Plex cache purged."
  else
    log "Plex cache directory not found."
  fi
}

plex_reset_perms() {
  local plex_user="plex"
  local plex_dir="/var/lib/plexmediaserver"
  chown -R "$plex_user":"$plex_user" "$plex_dir"
  log "Plex permissions reset."
}

plex_backup() {
  mkdir -p "$BACKUP_DIR/plex"
  local backup_file="$BACKUP_DIR/plex/plex_backup_$DATE.tar.gz"
  tar czf "$backup_file" "/var/lib/plexmediaserver"
  log "Plex backup created at $backup_file"
}

plex_backup_list() {
  ls -1 "$BACKUP_DIR/plex" | sort
}

plex_backup_restore() {
  local backup_file="$1"
  if [[ -f "$backup_file" ]]; then
    tar xzf "$backup_file" -C /
    log "Plex backup restored from $backup_file"
    plex_restart
  else
    log "Backup file $backup_file not found."
  fi
}

# Minecraft Commands ---------------------------------------------------------
mc_status() {
  systemctl status "$MC_SERVICE"
}

mc_start() {
  service_start "$MC_SERVICE"
}

mc_stop() {
  service_stop "$MC_SERVICE"
}

mc_restart() {
  systemctl restart "$MC_SERVICE"
  log "Minecraft restarted."
}

mc_fix() {
  log "Running Minecraft auto-fix diagnostics..."
  mc_clean_logs
  mc_validate_plugins
  mc_scan_heal
  mc_restart
  log "Minecraft auto-fix completed."
}

mc_clean_logs() {
  local mc_log_dir="/var/log/minecraft"
  if [[ -d "$mc_log_dir" ]]; then
    find "$mc_log_dir" -type f -name '*.log' -delete
    log "Minecraft logs cleaned."
  else
    log "Minecraft log directory not found."
  fi
}

mc_validate_plugins() {
  local mc_plugin_dir="/opt/minecraft/plugins"
  if [[ -d "$mc_plugin_dir" ]]; then
    # Example check: look for .jar files
    local invalid_plugins=$(find "$mc_plugin_dir" -type f ! -name '*.jar')
    if [[ -n "$invalid_plugins" ]]; then
      log "Invalid plugin files found in $mc_plugin_dir"
    else
      log "All plugins appear valid."
    fi
  else
    log "Minecraft plugin directory not found."
  fi
}

mc_scan_heal() {
  local mc_dir="/opt/minecraft"
  # Place holder for deep scan & heal - can integrate checksum, permission fix etc.
  log "Scanning and healing Minecraft server files..."
  # Example: fix perms
  chown -R minecraft:minecraft "$mc_dir"
  log "Minecraft server files permissions fixed."
}

mc_backup() {
  mkdir -p "$BACKUP_DIR/minecraft"
  local backup_file="$BACKUP_DIR/minecraft/mc_backup_$DATE.tar.gz"
  tar czf "$backup_file" "/opt/minecraft"
  log "Minecraft backup created at $backup_file"
}

mc_backup_list() {
  ls -1 "$BACKUP_DIR/minecraft" | sort
}

mc_backup_restore() {
  local backup_file="$1"
  if [[ -f "$backup_file" ]]; then
    tar xzf "$backup_file" -C /
    log "Minecraft backup restored from $backup_file"
    mc_restart
  else
    log "Backup file $backup_file not found."
  fi
}

mc_backup_restart() {
  mc_backup
  mc_restart
  log "Minecraft backup and restart completed."
}

mc_check_world() {
  local world_path="/opt/minecraft/world"
  if [[ -d "$world_path" ]]; then
    log "Checking Minecraft world integrity..."
    # Placeholder: could run specific MC tools here
    log "World directory exists and appears healthy."
  else
    log "Minecraft world directory not found."
  fi
}

# System Monitoring -----------------------------------------------------------
cpu() {
  top -bn1 | grep "Cpu(s)"
}

mem() {
  free -h
}

disk() {
  df -h
}

net() {
  ip -s link
}

packages() {
  dpkg -l | grep -E 'plex|minecraft|docker|fail2ban'
}

ports() {
  ss -tulpn | grep -E "plex|minecraft"
}

proc() {
  ps aux | grep -E "plex|minecraft"
}

svc_deps() {
  systemctl list-dependencies "$PLEX_SERVICE"
}

sys_info() {
  uname -a
  lsb_release -a
  hostnamectl
  systemctl status "$PLEX_SERVICE"
  systemctl status "$MC_SERVICE"
}

uptime() {
  uptime -p
}

uptime_full_days() {
  uptime
}

gpu_driver_status() {
  nvidia-smi || echo "No Nvidia GPU or driver found."
}

smart_health() {
  for disk in /dev/sd?; do
    smartctl -H "$disk" || echo "No SMART data for $disk"
  done
}

io_latency() {
  iostat -x 1 2 || echo "iostat not installed."
}

# System Maintenance & Repair -----------------------------------------------
auto_reboot() {
  log "Auto reboot trigger executed."
  reboot
}

cleanup_logs() {
  find /var/log -type f -name '*.log' -mtime +14 -exec rm -f {} \;
  log "Old logs cleaned up."
}

deps() {
  log "Checking & installing dependencies..."
  apt-get update
  apt-get install -y plexmediaserver minecraft-server smartmontools iostat sqlite3
}

drivers() {
  lshw -C display
  lsmod | grep -i nvidia
}

reboot() {
  systemctl reboot
}

sys_update() {
  apt-get update && apt-get upgrade -y
}

tmp_clean() {
  rm -rf /tmp/*
  log "/tmp cleaned."
}

upgrade() {
  # Placeholder for self upgrade
  log "Self upgrade not implemented yet."
}

mk_dir() {
  mkdir -p "$1"
  log "Directory $1 created."
}

rm() {
  rm -rf "$1"
  log "Removed $1"
}

auto_upgrade() {
  apt update && apt upgrade -y
  log "Auto upgrade completed."
}

auto_dist_upgrade() {
  apt dist-upgrade -y
  log "Auto dist-upgrade completed."
}

auto_clean_packages() {
  apt autoremove -y && apt clean
  log "Auto clean packages completed."
}

clean_temp() {
  rm -rf /tmp/*
  log "Temporary files cleaned."
}

clean_logs() {
  find /var/log -type f -mtime +14 -exec rm -f {} \;
  log "Old system logs cleaned."
}

clean_cache() {
  apt clean
  snap set system refresh.retain=2
  log "Caches cleaned."
}

check_disk_health() {
  smartctl --healthall || echo "SMART health check failed."
}

reboot_if_required() {
  if [[ -f /var/run/reboot-required ]]; then
    log "Reboot is required."
  else
    log "No reboot required."
  fi
}

turbo_mode() {
  auto_upgrade
  clean_logs
  tmp_clean
  reboot_if_required
  log "Turbo mode completed."
}

repair_sys_update() {
  sys_update
  reboot_if_required
}

repair_clean() {
  clean_temp
  clean_logs
  auto_clean_packages
}

repair_perms_daemon() {
  plex_reset_perms
  systemctl restart "$PLEX_SERVICE"
  systemctl restart "$MC_SERVICE"
  log "Service permissions reset and daemons restarted."
}

repair_security() {
  log "Running security audit..."
  lynis audit system || echo "Lynis not installed."
}

repair_integrity() {
  log "Checking file system integrity..."
  # Placeholder: run fsck or custom checks
  log "Integrity checks completed."
}

# Backup Management ----------------------------------------------------------
backup() {
  mkdir -p "$BACKUP_DIR/full"
  local backup_file="$BACKUP_DIR/full/full_backup_$DATE.tar.gz"
  tar czf "$backup_file" /etc /home /var/lib
  log "Full backup created at $backup_file"
}

backup_check() {
  local latest_backup
  latest_backup=$(ls -1t "$BACKUP_DIR/full"/*.tar.gz 2>/dev/null | head -1)
  if [[ -z "$latest_backup" ]]; then
    log "No backups found."
  else
    log "Verifying backup: $latest_backup"
    tar tzf "$latest_backup" > /dev/null && log "Backup is valid." || log "Backup is corrupted."
  fi
}

backup_clean() {
  find "$BACKUP_DIR" -type f -mtime +14 -exec rm -f {} \;
  log "Backups older than 14 days cleaned."
}

backup_restore() {
  local backup_file="$1"
  if [[ -f "$backup_file" ]]; then
    tar xzf "$backup_file" -C /
    log "Backup restored from $backup_file"
  else
    log "Backup file $backup_file not found."
  fi
}

system_backup() {
  mkdir -p "$BACKUP_DIR/system"
  local backup_file="$BACKUP_DIR/system/system_backup_$DATE.tar.gz"
  tar czf "$backup_file" /etc /var/lib
  log "System backup created at $backup_file"
}

system_backup_restore() {
  local backup_file="$1"
  if [[ -f "$backup_file" ]]; then
    tar xzf "$backup_file" -C /
    log "System backup restored from $backup_file"
  else
    log "System backup file $backup_file not found."
  fi
}

system_backup_list() {
  ls -1 "$BACKUP_DIR/system" | sort
}

# DuckDNS Service Control ----------------------------------------------------
duck_check() {
  [[ -f "$DUCKDNS_DIR/duck.sh" ]] && echo "DuckDNS script present." || echo "DuckDNS script missing."
}

duck_start() {
  systemctl enable --now duckdns.service duckdns.timer
  log "DuckDNS service and timer enabled and started."
}

duck_status() {
  systemctl status duckdns.service duckdns.timer
}

duck_stop() {
  systemctl disable --now duckdns.service duckdns.timer
  log "DuckDNS service and timer stopped and disabled."
}

duck_update() {
  bash "$DUCKDNS_DIR/duck.sh"
  log "DuckDNS IP updated."
}

duckdns_dir() {
  cd "$DUCKDNS_DIR" || log "DuckDNS directory $DUCKDNS_DIR not found."
}

# Linux Commands & Utilities -------------------------------------------------
alias() {
  alias
}

atq() {
  atq
}

bashrc_check() {
  grep -v '^#' ~/.bashrc
}

chkconfig() {
  runlevel 2>/dev/null || echo "chkconfig not available"
}

crontab() {
  crontab -l
}

curl() {
  curl --version
}

df() {
  df -h
}

env() {
  env
}

find_conf() {
  find /etc -type f -name '*.conf'
}

find_folders() {
  find . -type d
}

find_folders_all() {
  find /mnt -type d
}

find_logs() {
  find /var/log -type f -size +10M
}

find_scripts() {
  find /usr/local/bin -type f -executable
}

find_txt() {
  find . -type f -name '*.txt'
}

free() {
  free -h
}

groups() {
  groups
}

hostname() {
  hostname
}

id() {
  id
}

ip_addr() {
  ip addr show
}

ip_route() {
  ip route show
}

journalctl() {
  journalctl --no-pager -n 50
}

kill() {
  kill "$1"
}

last() {
  last -n 10
}

locale() {
  locale
}

lsb_release() {
  lsb_release -a
}

lsblk() {
  lsblk
}

lsmod() {
  lsmod
}

memory() {
  free -h
}

modinfo() {
  modinfo "$1"
}

mount() {
  mount | column -t
}

net_interfaces() {
  ip link show
}

netstat() {
  netstat -tulpn
}

open_ports() {
  ss -tulpn
}

os_info() {
  uname -a
}

ping() {
  ping -c 4 8.8.8.8
}

processes() {
  ps aux
}

profile_check() {
  cat /etc/profile
}

ps() {
  ps aux
}

rsync() {
  rsync --help
}

service() {
  systemctl status
}

ss() {
  ss -s
}

sys_logs() {
  tail -100 /var/log/syslog
}

timedatectl() {
  timedatectl
}

top() {
  top -bn1
}

traceroute() {
  traceroute 8.8.8.8
}

uname() {
  uname -a
}

uptime_days() {
  uptime -p
}

uptime_full() {
  uptime
}

uptime_secs() {
  cat /proc/uptime | awk '{print $1}'
}

wget() {
  wget --version
}

whoami() {
  whoami
}

clear_history() {
  history -c
}

convert_sh() {
  dos2unix "$1"
}

make_exec() {
  chmod +x "$1"
}

nano_edit() {
  nano "$1"
}

# Firewall and Security ------------------------------------------------------
fw_allow() {
  ufw allow "$1"
  log "Firewall allowed port/service $1"
}

fw_deny() {
  ufw deny "$1"
  log "Firewall denied port/service $1"
}

fw_disable() {
  ufw disable
  log "Firewall disabled."
}

fw_enable() {
  ufw enable
  log "Firewall enabled."
}

fw_status() {
  ufw status verbose
}

firewall_hard() {
  ufw default deny incoming
  ufw default allow outgoing
  ufw enable
  log "Firewall hardened."
}

chk_rootkits() {
  chkrootkit || rkhunter --check
}

fail2ban_check() {
  fail2ban-client status
}

passwd_audit() {
  # Placeholder for weak password check
  log "Password audit not implemented."
}

sec_audit() {
  lynis audit system || echo "Lynis not installed."
}

security_audit() {
  sec_audit
  chk_rootkits
  fail2ban_check
}

# Git Controls ---------------------------------------------------------------
git_clone() {
  git clone "$1"
}

git_pull() {
  git pull
}

git_status() {
  git status
}

# Service Management ---------------------------------------------------------
create_service() {
  # Placeholder: implement service creation logic
  log "Service creation not implemented."
}

svc_restart() {
  systemctl restart "$1"
  log "Service $1 restarted."
}

svc_start() {
  service_start "$1"
}

svc_stop() {
  service_stop "$1"
}

services_restart_all() {
  svc_restart "$PLEX_SERVICE"
  svc_restart "$MC_SERVICE"
  # Add other critical services here
  log "All critical services restarted."
}

# VBox Tiny 11 Controls ------------------------------------------------------
tiny11_cpus() {
  VBoxManage modifyvm "Tiny 11" --cpus "$1"
  log "Tiny 11 CPUs set to $1"
}

tiny11_memory() {
  VBoxManage modifyvm "Tiny 11" --memory "$1"
  log "Tiny 11 memory set to $1 MB"
}

tiny11_start() {
  VBoxManage startvm "Tiny 11" --type headless
  log "Tiny 11 VM started headless."
}

# Misc Utilities --------------------------------------------------------------
anton_dir() {
  cd /home/ANTON/anton.sh || log "ANTON directory not found."
}

papermc_dir() {
  cd /opt/papermc || log "PaperMC directory not found."
}

plex_env() {
  source /opt/plex_env/bin/activate || log "Plex environment not found."
}

# Search Functionality --------------------------------------------------------
search() {
  if [[ $# -lt 1 ]]; then
    echo "Usage: myrix search <term>"
    return 1
  fi
  local term="$1"
  log "Searching drives and directories for term: $term"
  find /mnt /media / -type f -iname "*${term}*" 2>/dev/null | head -100
}

# Help -----------------------------------------------------------------------
help() {
  cat << EOF
MYRIX v4 - Ultimate Linux Server Management Script

Usage: myrix <module> <command> [args]

Modules and commands:

plex      start|stop|restart|status|reload|backup|backup-list|backup-restore|fix|diagnose-db|purge-cache|reset-perms
minecraft start|stop|restart|status|backup|backup-list|backup-restore|fix|clean-logs|validate-plugins|scan-heal|check-world
system   update|upgrade|clean-logs|clean-temp|backup|backup-restore|status|info|reboot|auto-reboot|turbo-mode|repair-update|repair-clean|repair-perms|repair-security|repair-integrity
duckdns  start|stop|status|update|check|dir
backup   full|system|check|clean|restore|list
search   <term>  Search files and drives for a string
firewall start|stop|enable|disable|status|allow|deny|hard
git      clone|pull|status
vbox     tiny11-cpus|tiny11-memory|tiny11-start
misc     anton-dir|papermc-dir|plex-env

Examples:
myrix plex start
myrix minecraft backup
myrix system reboot
myrix duckdns update
myrix search plexmediaserver
myrix firewall hard

EOF
}

# Command dispatcher ----------------------------------------------------------
main() {
  local module="$1"
  shift || true

  case "$module" in
    plex)
      case "$1" in
        start) plex_start ;;
        stop) plex_stop ;;
        restart) plex_restart ;;
        status) plex_status ;;
        reload) plex_reload ;;
        backup) plex_backup ;;
        "backup-list") plex_backup_list ;;
        "backup-restore") plex_backup_restore "$2" ;;
        fix) plex_fix ;;
        "diagnose-db") plex_diagnose_db ;;
        "purge-cache") plex_purge_cache ;;
        "reset-perms") plex_reset_perms ;;
        *) echo "Unknown plex command: $1" ; help ;;
      esac ;;
    minecraft|mc)
      case "$1" in
        start) mc_start ;;
        stop) mc_stop ;;
        restart) mc_restart ;;
        status) mc_status ;;
        backup) mc_backup ;;
        "backup-list") mc_backup_list ;;
        "backup-restore") mc_backup_restore "$2" ;;
        fix) mc_fix ;;
        "clean-logs") mc_clean_logs ;;
        "validate-plugins") mc_validate_plugins ;;
        "scan-heal") mc_scan_heal ;;
        "check-world") mc_check_world ;;
        *) echo "Unknown minecraft command: $1" ; help ;;
      esac ;;
    system|sys)
      case "$1" in
        update) sys_update ;;
        upgrade) upgrade ;;
        "clean-logs") cleanup_logs ;;
        "clean-temp") clean_temp ;;
        backup) system_backup ;;
        "backup-restore") system_backup_restore "$2" ;;
        status) sys_info ;;
        info) sys_info ;;
        reboot) reboot ;;
        "auto-reboot") auto_reboot ;;
        "turbo-mode") turbo_mode ;;
        "repair-update") repair_sys_update ;;
        "repair-clean") repair_clean ;;
        "repair-perms") repair_perms_daemon ;;
        "repair-security") repair_security ;;
        "repair-integrity") repair_integrity ;;
        *) echo "Unknown system command: $1" ; help ;;
      esac ;;
    duckdns|duck)
      case "$1" in
        start) duck_start ;;
        stop) duck_stop ;;
        status) duck_status ;;
        update) duck_update ;;
        check) duck_check ;;
        dir) duckdns_dir ;;
        *) echo "Unknown duckdns command: $1" ; help ;;
      esac ;;
    backup)
      case "$1" in
        full) backup ;;
        system) system_backup ;;
        check) backup_check ;;
        clean) backup_clean ;;
        restore) backup_restore "$2" ;;
        list) system_backup_list ;;
        *) echo "Unknown backup command: $1" ; help ;;
      esac ;;
    firewall|fw)
      case "$1" in
        start|enable) fw_enable ;;
        stop|disable) fw_disable ;;
        status) fw_status ;;
        allow) fw_allow "$2" ;;
        deny) fw_deny "$2" ;;
        hard) firewall_hard ;;
        *) echo "Unknown firewall command: $1" ; help ;;
      esac ;;
    git)
      case "$1" in
        clone) git_clone "$2" ;;
        pull) git_pull ;;
        status) git_status ;;
        *) echo "Unknown git command: $1" ; help ;;
      esac ;;
    vbox)
      case "$1" in
        tiny11-cpus) tiny11_cpus "$2" ;;
        tiny11-memory) tiny11_memory "$2" ;;
        tiny11-start) tiny11_start ;;
        *) echo "Unknown vbox command: $1" ; help ;;
      esac ;;
    misc)
      case "$1" in
        anton-dir) anton_dir ;;
        papermc-dir) papermc_dir ;;
        plex-env) plex_env ;;
        *) echo "Unknown misc command: $1" ; help ;;
      esac ;;
    search)
      shift
      search "$@" ;;
    help|--help|-h|"")
      help ;;
    *)
      echo "Unknown module: $module"
      help ;;
  esac
}

# Bash completion skeleton
_myrix_completion() {
  local cur prev opts modules
  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"
  modules="plex minecraft system duckdns backup firewall git vbox misc search help"

  if [[ $COMP_CWORD == 1 ]]; then
    COMPREPLY=( $(compgen -W "$modules" -- "$cur") )
    return 0
  fi

  case "${COMP_WORDS[1]}" in
    plex)
      opts="start stop restart status reload backup backup-list backup-restore fix diagnose-db purge-cache reset-perms"
      ;;
    minecraft|mc)
      opts="start stop restart status backup backup-list backup-restore fix clean-logs validate-plugins scan-heal check-world"
      ;;
    system|sys)
      opts="update upgrade clean-logs clean-temp backup backup-restore status info reboot auto-reboot turbo-mode repair-update repair-clean repair-perms repair-security repair-integrity"
      ;;
    duckdns|duck)
      opts="start stop status update check dir"
      ;;
    backup)
      opts="full system check clean restore list"
      ;;
    firewall|fw)
      opts="start stop enable disable status allow deny hard"
      ;;
    git)
      opts="clone pull status"
      ;;
    vbox)
      opts="tiny11-cpus tiny11-memory tiny11-start"
      ;;
    misc)
      opts="anton-dir papermc-dir plex-env"
      ;;
    search)
      opts=""
      ;;
    *)
      opts=""
      ;;
  esac

  COMPREPLY=( $(compgen -W "$opts" -- "$cur") )
}

complete -F _myrix_completion myrix

# Entrypoint
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  if [[ $# -eq 0 ]]; then
    help
    exit 1
  fi
  main "$@"
fi
